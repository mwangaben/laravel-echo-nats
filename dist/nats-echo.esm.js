import{JSONCodec as t,connect as e}from"nats.ws";class n{constructor(t,e,n={}){this.connector=t,this.name=e,this.options=n}listen(t,e){return this.connector.listen(this.name,t,e),this}notification(t){return this.listen("Illuminate\\Notifications\\Events\\BroadcastNotificationCreated",t)}listenForWhisper(t,e){return this.listen(".client-"+t,e)}stopListening(t){return this}}class s extends n{constructor(t,e,n={}){super(t,"private-"+e,n)}}class o extends n{constructor(t,e,n={}){super(t,"private-encrypted-"+e,n)}}class i extends n{constructor(t,e,n={}){super(t,"presence-"+e,n)}here(t){return this.listen("presence:here",t)}joining(t){return this.listen("presence:joining",t)}leaving(t){return this.listen("presence:leaving",t)}}class c{constructor(e={}){this.natsConnection=null,this.jsonCodec=t(),this.subscriptions=new Map,this.eventCallbacks=new Map,this.reconnectAttempts=0,this.maxReconnectAttempts=5,this.isConnecting=!1,this.connectionPromise=null,this.options={host:"ws://localhost:4222",timeout:5e3,prefix:"",reconnects:5,debug:!1,namespace:"App.Events",...e},this.currentSocketId=this.generateSocketId()}generateSocketId(){return"nats_"+Math.random().toString(36).substr(2,9)+"_"+Date.now()}async connect(){return this.connectionPromise||(this.connectionPromise=this.establishConnection()),this.connectionPromise}async establishConnection(){if(!this.isConnecting&&!this.natsConnection){this.isConnecting=!0;try{const t=this.options.servers||this.options.host;this.options.debug&&console.log("NATS Echo: Connecting to",t),this.natsConnection=await e({servers:t,user:this.options.user,pass:this.options.pass,token:this.options.token,timeout:this.options.timeout,reconnect:!0,maxReconnectAttempts:this.options.reconnects,waitOnFirstConnect:!0}),this.setupConnectionEvents(),this.options.debug&&console.log("NATS Echo: Connected successfully"),await this.resubscribeAll()}catch(t){throw console.error("NATS Echo: Connection failed",t),t}finally{this.isConnecting=!1,this.connectionPromise=null}}}setupConnectionEvents(){this.natsConnection&&(this.natsConnection.closed().then(()=>{this.options.debug&&console.log("NATS Echo: Connection closed"),this.natsConnection=null}).catch(t=>{console.error("NATS Echo: Connection closed with error",t),this.natsConnection=null}),(async()=>{for await(const t of this.natsConnection.status())this.options.debug&&console.log("NATS Echo: Connection status:",t.type),"disconnect"===t.type||"error"===t.type?(this.reconnectAttempts++,this.reconnectAttempts>this.maxReconnectAttempts&&(console.error("NATS Echo: Max reconnection attempts reached"),this.cleanup())):"reconnect"===t.type&&(this.reconnectAttempts=0,this.resubscribeAll())})())}async resubscribeAll(){const t=Array.from(this.subscriptions.keys());this.subscriptions.forEach(t=>t.unsubscribe()),this.subscriptions.clear();for(const e of t)await this.subscribeToSubject(e)}async subscribeToSubject(t){if(this.natsConnection||await this.connect(),!this.subscriptions.has(t))try{const e=this.natsConnection.subscribe(t,{callback:(e,n)=>{if(e)console.error("NATS Echo: Subscription error",e);else try{const e=this.jsonCodec.decode(n.data);this.handleIncomingMessage(e,t)}catch(t){console.error("NATS Echo: Failed to decode message",t)}}});this.subscriptions.set(t,e),this.options.debug&&console.log(`NATS Echo: Subscribed to ${t}`)}catch(e){console.error(`NATS Echo: Failed to subscribe to ${t}`,e)}}getSubjectFromChannel(t){let e=t.replace(/\./g,"-");return this.options.prefix&&(e=`${this.options.prefix}.${e}`),e}handleIncomingMessage(t,e){this.options.debug&&console.log("NATS Echo: Received message",t,"on subject",e);const n=t.channel;let s=t.event;if(!s||!n)return void(this.options.debug&&console.warn("NATS Echo: Received message without event or channel",t));this.options.namespace&&s.startsWith(this.options.namespace+".")&&(s=s.substring(this.options.namespace.length+1));const o=s.startsWith(".")?s:`.${s}`,i=this.eventCallbacks.get(n);if(!i)return;(i.get(o)||i.get(s)||[]).forEach(e=>{try{e(t.data||t)}catch(t){console.error(`NATS Echo: Error in callback for ${n}@${s}`,t)}})}listen(t,e,n){const s=this.getSubjectFromChannel(t);this.eventCallbacks.has(t)||this.eventCallbacks.set(t,new Map);const o=this.eventCallbacks.get(t);o.has(e)||o.set(e,[]),o.get(e).push(n),this.subscribeToSubject(s)}channel(t){return new n(this,t)}privateChannel(t){return new s(this,t)}encryptedPrivateChannel(t){return new o(this,t)}join(t){return new i(this,t)}leave(t){if(this.eventCallbacks.get(t)){for(const[e,n]of this.subscriptions.entries())e.startsWith(this.getSubjectFromChannel(t))&&(n.unsubscribe(),this.subscriptions.delete(e));this.eventCallbacks.delete(t)}}socketId(){return this.currentSocketId}disconnect(){this.cleanup()}cleanup(){this.subscriptions.forEach(t=>{t.unsubscribe()}),this.subscriptions.clear(),this.eventCallbacks.clear(),this.natsConnection&&(this.natsConnection.close(),this.natsConnection=null)}}const r={install(t,e={}){const n=new c(e);return t.connector=n,t.nats=n,t.channel.bind(t),t.private.bind(t),t.encryptedPrivate.bind(t),t.join.bind(t),t.channel=t=>n.channel(t),t.private=t=>n.privateChannel(t),t.encryptedPrivate=t=>n.encryptedPrivateChannel(t),t.join=t=>n.join(t),t.leave=t=>n.leave(t),t.leaveChannel=t.leave,n.connect().catch(t=>{console.error("NATS Echo: Failed to connect",t)}),t}};export{n as Channel,o as EncryptedPrivateChannel,r as NatsBroadcaster,c as NatsConnector,i as PresenceChannel,s as PrivateChannel,r as default};
